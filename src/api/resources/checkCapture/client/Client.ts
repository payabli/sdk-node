// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../BaseClient.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import * as core from "../../../../core/index.js";
import * as environments from "../../../../environments.js";
import * as errors from "../../../../errors/index.js";
import * as Payabli from "../../../index.js";

export declare namespace CheckCapture {
    export interface Options extends BaseClientOptions {}

    export interface RequestOptions extends BaseRequestOptions {}
}

export class CheckCapture {
    protected readonly _options: CheckCapture.Options;

    constructor(_options: CheckCapture.Options = {}) {
        this._options = _options;
    }

    /**
     * Captures a check for Remote Deposit Capture (RDC) using the provided check images and details. This endpoint handles the OCR extraction of check data including MICR, routing number, account number, and amount. See the [RDC guide](/developers/developer-guides/pay-in-rdc) for more details.
     *
     * @param {Payabli.CheckCaptureRequestBody} request
     * @param {CheckCapture.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Payabli.BadRequestError}
     * @throws {@link Payabli.UnauthorizedError}
     * @throws {@link Payabli.InternalServerError}
     * @throws {@link Payabli.ServiceUnavailableError}
     *
     * @example
     *     await client.checkCapture.checkProcessing({
     *         entryPoint: "47abcfea12",
     *         frontImage: "/9j/4AAQSkZJRgABAQEASABIAAD...",
     *         rearImage: "/9j/4AAQSkZJRgABAQEASABIAAD...",
     *         checkAmount: 12550
     *     })
     */
    public checkProcessing(
        request: Payabli.CheckCaptureRequestBody,
        requestOptions?: CheckCapture.RequestOptions,
    ): core.HttpResponsePromise<Payabli.CheckCaptureResponse> {
        return core.HttpResponsePromise.fromPromise(this.__checkProcessing(request, requestOptions));
    }

    private async __checkProcessing(
        request: Payabli.CheckCaptureRequestBody,
        requestOptions?: CheckCapture.RequestOptions,
    ): Promise<core.WithRawResponse<Payabli.CheckCaptureResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PayabliEnvironment.Sandbox,
                "CheckCapture/CheckProcessing",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Payabli.CheckCaptureResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Payabli.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Payabli.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Payabli.InternalServerError(_response.error.body as unknown, _response.rawResponse);
                case 503:
                    throw new Payabli.ServiceUnavailableError(
                        _response.error.body as Payabli.PayabliApiResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PayabliError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.PayabliError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.PayabliTimeoutError(
                    "Timeout exceeded when calling POST /CheckCapture/CheckProcessing.",
                );
            case "unknown":
                throw new errors.PayabliError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getCustomAuthorizationHeaders(): Promise<Record<string, string | undefined>> {
        const apiKeyValue = await core.Supplier.get(this._options.apiKey);
        return { requestToken: apiKeyValue };
    }
}
