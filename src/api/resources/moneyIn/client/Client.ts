// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../BaseClient.js";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../BaseClient.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import * as core from "../../../../core/index.js";
import * as environments from "../../../../environments.js";
import { handleNonStatusCodeError } from "../../../../errors/handleNonStatusCodeError.js";
import * as errors from "../../../../errors/index.js";
import * as Payabli from "../../../index.js";

export declare namespace MoneyInClient {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

export class MoneyInClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<MoneyInClient.Options>;

    constructor(options: MoneyInClient.Options = {}) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    /**
     * Authorize a card transaction. This returns an authorization code and reserves funds for the merchant. Authorized transactions aren't flagged for settlement until [captured](/developers/api-reference/moneyin/capture-an-authorized-transaction).
     * Only card transactions can be authorized. This endpoint can't be used for ACH transactions.
     * <Tip>
     *   Consider migrating to the [v2 Authorize endpoint](/developers/api-reference/moneyinV2/authorize-a-transaction) to take advantage of unified response codes and improved response consistency.
     * </Tip>
     *
     * @param {Payabli.RequestPaymentAuthorize} request
     * @param {MoneyInClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Payabli.BadRequestError}
     * @throws {@link Payabli.UnauthorizedError}
     * @throws {@link Payabli.InternalServerError}
     * @throws {@link Payabli.ServiceUnavailableError}
     *
     * @example
     *     await client.moneyIn.authorize({
     *         body: {
     *             customerData: {
     *                 customerId: 4440
     *             },
     *             entryPoint: "f743aed24a",
     *             ipaddress: "255.255.255.255",
     *             paymentDetails: {
     *                 serviceFee: 0,
     *                 totalAmount: 100
     *             },
     *             paymentMethod: {
     *                 cardcvv: "999",
     *                 cardexp: "02/27",
     *                 cardHolder: "John Cassian",
     *                 cardnumber: "4111111111111111",
     *                 cardzip: "12345",
     *                 initiator: "payor",
     *                 method: "card"
     *             }
     *         }
     *     })
     */
    public authorize(
        request: Payabli.RequestPaymentAuthorize,
        requestOptions?: MoneyInClient.RequestOptions,
    ): core.HttpResponsePromise<Payabli.AuthResponse> {
        return core.HttpResponsePromise.fromPromise(this.__authorize(request, requestOptions));
    }

    private async __authorize(
        request: Payabli.RequestPaymentAuthorize,
        requestOptions?: MoneyInClient.RequestOptions,
    ): Promise<core.WithRawResponse<Payabli.AuthResponse>> {
        const { forceCustomerCreation, idempotencyKey, body: _body } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (forceCustomerCreation != null) {
            _queryParams.forceCustomerCreation = forceCustomerCreation.toString();
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({ idempotencyKey: idempotencyKey != null ? idempotencyKey : undefined }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PayabliEnvironment.Sandbox,
                "MoneyIn/authorize",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            requestType: "json",
            body: _body,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Payabli.AuthResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Payabli.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Payabli.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Payabli.InternalServerError(_response.error.body as unknown, _response.rawResponse);
                case 503:
                    throw new Payabli.ServiceUnavailableError(
                        _response.error.body as Payabli.PayabliApiResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PayabliError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/MoneyIn/authorize");
    }

    /**
     * <Warning>
     *   This endpoint is deprecated and will be sunset on November 24, 2025. Migrate to [POST `/capture/{transId}`](/developers/api-reference/moneyin/capture-an-authorized-transaction)`.
     * </Warning>
     *
     *   Capture an [authorized
     * transaction](/developers/api-reference/moneyin/authorize-a-transaction) to complete the transaction and move funds from the customer to merchant account.
     *
     * @param {string} transId - ReferenceId for the transaction (PaymentId).
     * @param {number} amount - Amount to be captured. The amount can't be greater the original total amount of the transaction. `0` captures the total amount authorized in the transaction. Partial captures aren't supported.
     * @param {MoneyInClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Payabli.BadRequestError}
     * @throws {@link Payabli.UnauthorizedError}
     * @throws {@link Payabli.InternalServerError}
     * @throws {@link Payabli.ServiceUnavailableError}
     *
     * @example
     *     await client.moneyIn.capture("10-7d9cd67d-2d5d-4cd7-a1b7-72b8b201ec13", 0)
     */
    public capture(
        transId: string,
        amount: number,
        requestOptions?: MoneyInClient.RequestOptions,
    ): core.HttpResponsePromise<Payabli.CaptureResponse> {
        return core.HttpResponsePromise.fromPromise(this.__capture(transId, amount, requestOptions));
    }

    private async __capture(
        transId: string,
        amount: number,
        requestOptions?: MoneyInClient.RequestOptions,
    ): Promise<core.WithRawResponse<Payabli.CaptureResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PayabliEnvironment.Sandbox,
                `MoneyIn/capture/${core.url.encodePathParam(transId)}/${core.url.encodePathParam(amount)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Payabli.CaptureResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Payabli.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Payabli.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Payabli.InternalServerError(_response.error.body as unknown, _response.rawResponse);
                case 503:
                    throw new Payabli.ServiceUnavailableError(
                        _response.error.body as Payabli.PayabliApiResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PayabliError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/MoneyIn/capture/{transId}/{amount}",
        );
    }

    /**
     * Capture an [authorized transaction](/developers/api-reference/moneyin/authorize-a-transaction) to complete the transaction and move funds from the customer to merchant account.
     *
     * You can use this endpoint to capture both full and partial amounts of the original authorized transaction. See [Capture an authorized transaction](/developers/developer-guides/pay-in-auth-and-capture) for more information about this endpoint.
     *
     * <Tip>
     * Consider migrating to the [v2 Capture endpoint](/developers/api-reference/moneyinV2/capture-an-authorized-transaction) to take advantage of unified response codes and improved response consistency.
     * </Tip>
     *
     * @param {string} transId - ReferenceId for the transaction (PaymentId).
     * @param {Payabli.CaptureRequest} request
     * @param {MoneyInClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Payabli.BadRequestError}
     * @throws {@link Payabli.UnauthorizedError}
     * @throws {@link Payabli.InternalServerError}
     * @throws {@link Payabli.ServiceUnavailableError}
     *
     * @example
     *     await client.moneyIn.captureAuth("10-7d9cd67d-2d5d-4cd7-a1b7-72b8b201ec13", {
     *         paymentDetails: {
     *             totalAmount: 105,
     *             serviceFee: 5
     *         }
     *     })
     *
     * @example
     *     await client.moneyIn.captureAuth("10-7d9cd67d-2d5d-4cd7-a1b7-72b8b201ec13", {
     *         paymentDetails: {
     *             totalAmount: 89,
     *             serviceFee: 4
     *         }
     *     })
     *
     * @example
     *     await client.moneyIn.captureAuth("10-7d9cd67d-2d5d-4cd7-a1b7-72b8b201ec13", {
     *         paymentDetails: {
     *             totalAmount: 100
     *         }
     *     })
     */
    public captureAuth(
        transId: string,
        request: Payabli.CaptureRequest,
        requestOptions?: MoneyInClient.RequestOptions,
    ): core.HttpResponsePromise<Payabli.CaptureResponse> {
        return core.HttpResponsePromise.fromPromise(this.__captureAuth(transId, request, requestOptions));
    }

    private async __captureAuth(
        transId: string,
        request: Payabli.CaptureRequest,
        requestOptions?: MoneyInClient.RequestOptions,
    ): Promise<core.WithRawResponse<Payabli.CaptureResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PayabliEnvironment.Sandbox,
                `MoneyIn/capture/${core.url.encodePathParam(transId)}`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Payabli.CaptureResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Payabli.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Payabli.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Payabli.InternalServerError(_response.error.body as unknown, _response.rawResponse);
                case 503:
                    throw new Payabli.ServiceUnavailableError(
                        _response.error.body as Payabli.PayabliApiResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PayabliError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/MoneyIn/capture/{transId}");
    }

    /**
     * Make a temporary microdeposit in a customer account to verify the customer's ownership and access to the target account. Reverse the microdeposit with `reverseCredit`.
     *
     * This feature must be enabled by Payabli on a per-merchant basis. Contact support for help.
     *
     * @param {Payabli.RequestCredit} request
     * @param {MoneyInClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Payabli.BadRequestError}
     * @throws {@link Payabli.UnauthorizedError}
     * @throws {@link Payabli.InternalServerError}
     * @throws {@link Payabli.ServiceUnavailableError}
     *
     * @example
     *     await client.moneyIn.credit({
     *         idempotencyKey: "6B29FC40-CA47-1067-B31D-00DD010662DA",
     *         customerData: {
     *             billingAddress1: "5127 Linkwood ave",
     *             customerNumber: "100"
     *         },
     *         entrypoint: "my-entrypoint",
     *         paymentDetails: {
     *             serviceFee: 0,
     *             totalAmount: 1
     *         },
     *         paymentMethod: {
     *             achAccount: "88354454",
     *             achAccountType: "Checking",
     *             achHolder: "John Smith",
     *             achRouting: "021000021",
     *             method: "ach"
     *         }
     *     })
     *
     * @example
     *     await client.moneyIn.credit({
     *         idempotencyKey: "6B29FC40-CA47-1067-B31D-00DD010662DA",
     *         customerData: {
     *             billingAddress1: "125 Main Street",
     *             billingCity: "Kingsport",
     *             billingEmail: "johnnyp@email.com",
     *             company: "Acme, Inc",
     *             customerNumber: "100",
     *             firstName: "Johnny",
     *             lastName: "Poulsbo"
     *         },
     *         entrypoint: "my-entrypoint",
     *         paymentDetails: {
     *             serviceFee: 0,
     *             totalAmount: 1
     *         },
     *         paymentMethod: {
     *             achAccount: "88354554",
     *             achAccountType: "Checking",
     *             achHolder: "John Poulsbo",
     *             achRouting: "029000021",
     *             method: "ach"
     *         }
     *     })
     */
    public credit(
        request: Payabli.RequestCredit,
        requestOptions?: MoneyInClient.RequestOptions,
    ): core.HttpResponsePromise<Payabli.PayabliApiResponse0> {
        return core.HttpResponsePromise.fromPromise(this.__credit(request, requestOptions));
    }

    private async __credit(
        request: Payabli.RequestCredit,
        requestOptions?: MoneyInClient.RequestOptions,
    ): Promise<core.WithRawResponse<Payabli.PayabliApiResponse0>> {
        const { forceCustomerCreation, idempotencyKey, ..._body } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (forceCustomerCreation != null) {
            _queryParams.forceCustomerCreation = forceCustomerCreation.toString();
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({ idempotencyKey: idempotencyKey != null ? idempotencyKey : undefined }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PayabliEnvironment.Sandbox,
                "MoneyIn/makecredit",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            requestType: "json",
            body: _body,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Payabli.PayabliApiResponse0, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Payabli.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Payabli.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Payabli.InternalServerError(_response.error.body as unknown, _response.rawResponse);
                case 503:
                    throw new Payabli.ServiceUnavailableError(
                        _response.error.body as Payabli.PayabliApiResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PayabliError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/MoneyIn/makecredit");
    }

    /**
     * Retrieve a processed transaction's details.
     *
     * @param {string} transId - ReferenceId for the transaction (PaymentId).
     * @param {MoneyInClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Payabli.BadRequestError}
     * @throws {@link Payabli.UnauthorizedError}
     * @throws {@link Payabli.InternalServerError}
     * @throws {@link Payabli.ServiceUnavailableError}
     *
     * @example
     *     await client.moneyIn.details("45-as456777hhhhhhhhhh77777777-324")
     */
    public details(
        transId: string,
        requestOptions?: MoneyInClient.RequestOptions,
    ): core.HttpResponsePromise<Payabli.TransactionQueryRecordsCustomer> {
        return core.HttpResponsePromise.fromPromise(this.__details(transId, requestOptions));
    }

    private async __details(
        transId: string,
        requestOptions?: MoneyInClient.RequestOptions,
    ): Promise<core.WithRawResponse<Payabli.TransactionQueryRecordsCustomer>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PayabliEnvironment.Sandbox,
                `MoneyIn/details/${core.url.encodePathParam(transId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: _response.body as Payabli.TransactionQueryRecordsCustomer,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Payabli.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Payabli.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Payabli.InternalServerError(_response.error.body as unknown, _response.rawResponse);
                case 503:
                    throw new Payabli.ServiceUnavailableError(
                        _response.error.body as Payabli.PayabliApiResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PayabliError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/MoneyIn/details/{transId}");
    }

    /**
     * Make a single transaction. This method authorizes and captures a payment in one step.
     *
     *   <Tip>
     *   Consider migrating to the [v2 Make a transaction endpoint](/developers/api-reference/moneyinV2/make-a-transaction) to take advantage of unified response codes and improved response consistency.
     *   </Tip>
     *
     * @param {Payabli.RequestPayment} request
     * @param {MoneyInClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Payabli.BadRequestError}
     * @throws {@link Payabli.UnauthorizedError}
     * @throws {@link Payabli.InternalServerError}
     * @throws {@link Payabli.ServiceUnavailableError}
     *
     * @example
     *     await client.moneyIn.getpaid({
     *         body: {
     *             customerData: {
     *                 customerId: 4440
     *             },
     *             entryPoint: "f743aed24a",
     *             ipaddress: "255.255.255.255",
     *             paymentDetails: {
     *                 serviceFee: 0,
     *                 totalAmount: 100
     *             },
     *             paymentMethod: {
     *                 cardcvv: "999",
     *                 cardexp: "02/27",
     *                 cardHolder: "John Cassian",
     *                 cardnumber: "4111111111111111",
     *                 cardzip: "12345",
     *                 initiator: "payor",
     *                 method: "card"
     *             }
     *         }
     *     })
     *
     * @example
     *     await client.moneyIn.getpaid({
     *         body: {
     *             customerData: {
     *                 customerId: 4440
     *             },
     *             entryPoint: "f743aed24a",
     *             ipaddress: "255.255.255.255",
     *             paymentDetails: {
     *                 serviceFee: 0,
     *                 totalAmount: 100
     *             },
     *             paymentMethod: {
     *                 initiator: "payor",
     *                 method: "card",
     *                 storedMethodId: "1ec55af9-7b5a-4ff0-81ed-c12d2f95e135-4440",
     *                 storedMethodUsageType: "unscheduled"
     *             }
     *         }
     *     })
     *
     * @example
     *     await client.moneyIn.getpaid({
     *         body: {
     *             customerData: {
     *                 customerId: 4440
     *             },
     *             entryPoint: "f743aed24a",
     *             ipaddress: "255.255.255.255",
     *             paymentDetails: {
     *                 serviceFee: 0,
     *                 totalAmount: 100
     *             },
     *             paymentMethod: {
     *                 device: "6c361c7d-674c-44cc-b790-382b75d1xxx",
     *                 method: "cloud",
     *                 saveIfSuccess: true
     *             }
     *         }
     *     })
     *
     * @example
     *     await client.moneyIn.getpaid({
     *         body: {
     *             customerData: {
     *                 customerId: 4440
     *             },
     *             entryPoint: "f743aed24a",
     *             ipaddress: "255.255.255.255",
     *             paymentDetails: {
     *                 serviceFee: 0,
     *                 totalAmount: 100
     *             },
     *             paymentMethod: {
     *                 achAccount: "123123123",
     *                 achAccountType: "Checking",
     *                 achCode: "WEB",
     *                 achHolder: "John Cassian",
     *                 achHolderType: "personal",
     *                 achRouting: "123123123",
     *                 method: "ach"
     *             }
     *         }
     *     })
     *
     * @example
     *     await client.moneyIn.getpaid({
     *         body: {
     *             customerData: {
     *                 billingAddress1: "123 Walnut Street",
     *                 billingCity: "Johnson City",
     *                 billingCountry: "US",
     *                 billingEmail: "john@email.com",
     *                 billingPhone: "1234567890",
     *                 billingState: "Johnson City",
     *                 billingZip: "37615",
     *                 customerNumber: "3456-7645A",
     *                 firstName: "John",
     *                 lastName: "Cassian"
     *             },
     *             entryPoint: "f743aed24a",
     *             ipaddress: "255.255.255.255",
     *             orderDescription: "New customer package",
     *             orderId: "982-102",
     *             paymentDetails: {
     *                 serviceFee: 0,
     *                 totalAmount: 1000
     *             },
     *             paymentMethod: {
     *                 cardcvv: "123",
     *                 cardexp: "02/25",
     *                 cardHolder: "John Cassian",
     *                 cardnumber: "4111111111111111",
     *                 cardzip: "12345",
     *                 initiator: "payor",
     *                 method: "card",
     *                 saveIfSuccess: true
     *             },
     *             source: "web"
     *         }
     *     })
     *
     * @example
     *     await client.moneyIn.getpaid({
     *         body: {
     *             customerData: {
     *                 customerId: 4440
     *             },
     *             entryPoint: "f743aed24a",
     *             ipaddress: "255.255.255.255",
     *             paymentDetails: {
     *                 serviceFee: 0,
     *                 totalAmount: 100,
     *                 currency: "CAD"
     *             },
     *             paymentMethod: {
     *                 cardcvv: "999",
     *                 cardexp: "02/27",
     *                 cardHolder: "John Cassian",
     *                 cardnumber: "4111111111111111",
     *                 cardzip: "12345",
     *                 initiator: "payor",
     *                 method: "card"
     *             }
     *         }
     *     })
     */
    public getpaid(
        request: Payabli.RequestPayment,
        requestOptions?: MoneyInClient.RequestOptions,
    ): core.HttpResponsePromise<Payabli.PayabliApiResponseGetPaid> {
        return core.HttpResponsePromise.fromPromise(this.__getpaid(request, requestOptions));
    }

    private async __getpaid(
        request: Payabli.RequestPayment,
        requestOptions?: MoneyInClient.RequestOptions,
    ): Promise<core.WithRawResponse<Payabli.PayabliApiResponseGetPaid>> {
        const {
            achValidation,
            forceCustomerCreation,
            includeDetails,
            idempotencyKey,
            validationCode,
            body: _body,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (achValidation != null) {
            _queryParams.achValidation = achValidation.toString();
        }

        if (forceCustomerCreation != null) {
            _queryParams.forceCustomerCreation = forceCustomerCreation.toString();
        }

        if (includeDetails != null) {
            _queryParams.includeDetails = includeDetails.toString();
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                idempotencyKey: idempotencyKey != null ? idempotencyKey : undefined,
                validationCode: validationCode != null ? validationCode : undefined,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PayabliEnvironment.Sandbox,
                "MoneyIn/getpaid",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            requestType: "json",
            body: _body,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Payabli.PayabliApiResponseGetPaid, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Payabli.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Payabli.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Payabli.InternalServerError(_response.error.body as unknown, _response.rawResponse);
                case 503:
                    throw new Payabli.ServiceUnavailableError(
                        _response.error.body as Payabli.PayabliApiResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PayabliError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/MoneyIn/getpaid");
    }

    /**
     * A reversal either refunds or voids a transaction independent of the transaction's settlement status. Send a reversal request for a transaction, and Payabli automatically determines whether it's a refund or void. You don't need to know whether the transaction is settled or not.
     *
     * @param {string} transId - ReferenceId for the transaction (PaymentId).
     * @param {number} amount -
     *                          Amount to reverse from original transaction, minus any service fees charged on the original transaction.
     *
     *                          The amount provided can't be greater than the original total amount of the transaction, minus service fees. For example, if a transaction was $90 plus a $10 service fee, you can reverse up to $90.
     *
     *                          An amount equal to zero will refunds the total amount authorized minus any service fee.
     * @param {MoneyInClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Payabli.BadRequestError}
     * @throws {@link Payabli.UnauthorizedError}
     * @throws {@link Payabli.InternalServerError}
     * @throws {@link Payabli.ServiceUnavailableError}
     *
     * @example
     *     await client.moneyIn.reverse("10-3ffa27df-b171-44e0-b251-e95fbfc7a723", 0)
     *
     * @example
     *     await client.moneyIn.reverse("10-3ffa27df-b171-44e0-b251-e95fbfc7a723", 53.76)
     */
    public reverse(
        transId: string,
        amount: number,
        requestOptions?: MoneyInClient.RequestOptions,
    ): core.HttpResponsePromise<Payabli.ReverseResponse> {
        return core.HttpResponsePromise.fromPromise(this.__reverse(transId, amount, requestOptions));
    }

    private async __reverse(
        transId: string,
        amount: number,
        requestOptions?: MoneyInClient.RequestOptions,
    ): Promise<core.WithRawResponse<Payabli.ReverseResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PayabliEnvironment.Sandbox,
                `MoneyIn/reverse/${core.url.encodePathParam(transId)}/${core.url.encodePathParam(amount)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Payabli.ReverseResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Payabli.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Payabli.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Payabli.InternalServerError(_response.error.body as unknown, _response.rawResponse);
                case 503:
                    throw new Payabli.ServiceUnavailableError(
                        _response.error.body as Payabli.PayabliApiResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PayabliError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/MoneyIn/reverse/{transId}/{amount}",
        );
    }

    /**
     * Refund a transaction that has settled and send money back to the account holder. If a transaction hasn't been settled, void it instead.
     *
     *   <Tip>
     *   Consider migrating to the [v2 Refund endpoint](/developers/api-reference/moneyinV2/refund-a-settled-transaction) to take advantage of unified response codes and improved response consistency.
     *   </Tip>
     *
     * @param {string} transId - ReferenceId for the transaction (PaymentId).
     * @param {number} amount -
     *                          Amount to refund from original transaction, minus any service fees charged on the original transaction.
     *
     *                          The amount provided can't be greater than the original total amount of the transaction, minus service fees. For example, if a transaction was \$90 plus a \$10 service fee, you can refund up to \$90.
     *
     *                          An amount equal to zero will refund the total amount authorized minus any service fee.
     * @param {MoneyInClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Payabli.BadRequestError}
     * @throws {@link Payabli.UnauthorizedError}
     * @throws {@link Payabli.InternalServerError}
     * @throws {@link Payabli.ServiceUnavailableError}
     *
     * @example
     *     await client.moneyIn.refund("10-3ffa27df-b171-44e0-b251-e95fbfc7a723", 0)
     *
     * @example
     *     await client.moneyIn.refund("10-3ffa27df-b171-44e0-b251-e95fbfc7a723", 100.99)
     */
    public refund(
        transId: string,
        amount: number,
        requestOptions?: MoneyInClient.RequestOptions,
    ): core.HttpResponsePromise<Payabli.RefundResponse> {
        return core.HttpResponsePromise.fromPromise(this.__refund(transId, amount, requestOptions));
    }

    private async __refund(
        transId: string,
        amount: number,
        requestOptions?: MoneyInClient.RequestOptions,
    ): Promise<core.WithRawResponse<Payabli.RefundResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PayabliEnvironment.Sandbox,
                `MoneyIn/refund/${core.url.encodePathParam(transId)}/${core.url.encodePathParam(amount)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Payabli.RefundResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Payabli.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Payabli.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Payabli.InternalServerError(_response.error.body as unknown, _response.rawResponse);
                case 503:
                    throw new Payabli.ServiceUnavailableError(
                        _response.error.body as Payabli.PayabliApiResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PayabliError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/MoneyIn/refund/{transId}/{amount}",
        );
    }

    /**
     * Refunds a settled transaction with split instructions.
     *
     * @param {string} transId - ReferenceId for the transaction (PaymentId).
     * @param {Payabli.RequestRefund} request
     * @param {MoneyInClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Payabli.BadRequestError}
     * @throws {@link Payabli.UnauthorizedError}
     * @throws {@link Payabli.InternalServerError}
     * @throws {@link Payabli.ServiceUnavailableError}
     *
     * @example
     *     await client.moneyIn.refundWithInstructions("10-3ffa27df-b171-44e0-b251-e95fbfc7a723", {
     *         idempotencyKey: "8A29FC40-CA47-1067-B31D-00DD010662DB",
     *         source: "api",
     *         orderDescription: "Materials deposit",
     *         amount: 100,
     *         refundDetails: {
     *             splitRefunding: [{
     *                     originationEntryPoint: "7f1a381696",
     *                     accountId: "187-342",
     *                     description: "Refunding undelivered materials",
     *                     amount: 60
     *                 }, {
     *                     originationEntryPoint: "7f1a381696",
     *                     accountId: "187-343",
     *                     description: "Refunding deposit for undelivered materials",
     *                     amount: 40
     *                 }]
     *         }
     *     })
     *
     * @example
     *     await client.moneyIn.refundWithInstructions("10-3ffa27df-b171-44e0-b251-e95fbfc7a723", {
     *         idempotencyKey: "8A29FC40-CA47-1067-B31D-00DD010662DB",
     *         source: "api",
     *         orderDescription: "Materials deposit",
     *         amount: 70,
     *         refundDetails: {
     *             splitRefunding: [{
     *                     originationEntryPoint: "7f1a381696",
     *                     accountId: "187-342",
     *                     description: "Refunding undelivered materials",
     *                     amount: 40
     *                 }, {
     *                     originationEntryPoint: "7f1a381696",
     *                     accountId: "187-343",
     *                     description: "Refunding deposit for undelivered materials",
     *                     amount: 30
     *                 }]
     *         }
     *     })
     */
    public refundWithInstructions(
        transId: string,
        request: Payabli.RequestRefund = {},
        requestOptions?: MoneyInClient.RequestOptions,
    ): core.HttpResponsePromise<Payabli.RefundWithInstructionsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__refundWithInstructions(transId, request, requestOptions));
    }

    private async __refundWithInstructions(
        transId: string,
        request: Payabli.RequestRefund = {},
        requestOptions?: MoneyInClient.RequestOptions,
    ): Promise<core.WithRawResponse<Payabli.RefundWithInstructionsResponse>> {
        const { idempotencyKey, ..._body } = request;
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({ idempotencyKey: idempotencyKey != null ? idempotencyKey : undefined }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PayabliEnvironment.Sandbox,
                `MoneyIn/refund/${core.url.encodePathParam(transId)}`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: _body,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: _response.body as Payabli.RefundWithInstructionsResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Payabli.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Payabli.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Payabli.InternalServerError(_response.error.body as unknown, _response.rawResponse);
                case 503:
                    throw new Payabli.ServiceUnavailableError(
                        _response.error.body as Payabli.PayabliApiResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PayabliError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/MoneyIn/refund/{transId}");
    }

    /**
     * Reverse microdeposits that are used to verify customer account ownership and access. The `transId` value is returned in the success response for the original credit transaction made with `api/MoneyIn/makecredit`.
     *
     * @param {string} transId - ReferenceId for the transaction (PaymentId).
     * @param {MoneyInClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Payabli.BadRequestError}
     * @throws {@link Payabli.UnauthorizedError}
     * @throws {@link Payabli.InternalServerError}
     * @throws {@link Payabli.ServiceUnavailableError}
     *
     * @example
     *     await client.moneyIn.reverseCredit("45-as456777hhhhhhhhhh77777777-324")
     */
    public reverseCredit(
        transId: string,
        requestOptions?: MoneyInClient.RequestOptions,
    ): core.HttpResponsePromise<Payabli.PayabliApiResponse> {
        return core.HttpResponsePromise.fromPromise(this.__reverseCredit(transId, requestOptions));
    }

    private async __reverseCredit(
        transId: string,
        requestOptions?: MoneyInClient.RequestOptions,
    ): Promise<core.WithRawResponse<Payabli.PayabliApiResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PayabliEnvironment.Sandbox,
                `MoneyIn/reverseCredit/${core.url.encodePathParam(transId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Payabli.PayabliApiResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Payabli.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Payabli.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Payabli.InternalServerError(_response.error.body as unknown, _response.rawResponse);
                case 503:
                    throw new Payabli.ServiceUnavailableError(
                        _response.error.body as Payabli.PayabliApiResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PayabliError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/MoneyIn/reverseCredit/{transId}",
        );
    }

    /**
     * Send a payment receipt for a transaction.
     *
     * @param {string} transId - ReferenceId for the transaction (PaymentId).
     * @param {Payabli.SendReceipt2TransRequest} request
     * @param {MoneyInClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Payabli.BadRequestError}
     * @throws {@link Payabli.UnauthorizedError}
     * @throws {@link Payabli.InternalServerError}
     * @throws {@link Payabli.ServiceUnavailableError}
     *
     * @example
     *     await client.moneyIn.sendReceipt2Trans("45-as456777hhhhhhhhhh77777777-324", {
     *         email: "example@email.com"
     *     })
     */
    public sendReceipt2Trans(
        transId: string,
        request: Payabli.SendReceipt2TransRequest = {},
        requestOptions?: MoneyInClient.RequestOptions,
    ): core.HttpResponsePromise<Payabli.ReceiptResponse> {
        return core.HttpResponsePromise.fromPromise(this.__sendReceipt2Trans(transId, request, requestOptions));
    }

    private async __sendReceipt2Trans(
        transId: string,
        request: Payabli.SendReceipt2TransRequest = {},
        requestOptions?: MoneyInClient.RequestOptions,
    ): Promise<core.WithRawResponse<Payabli.ReceiptResponse>> {
        const { email } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (email != null) {
            _queryParams.email = email;
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PayabliEnvironment.Sandbox,
                `MoneyIn/sendreceipt/${core.url.encodePathParam(transId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Payabli.ReceiptResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Payabli.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Payabli.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Payabli.InternalServerError(_response.error.body as unknown, _response.rawResponse);
                case 503:
                    throw new Payabli.ServiceUnavailableError(
                        _response.error.body as Payabli.PayabliApiResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PayabliError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "GET",
            "/MoneyIn/sendreceipt/{transId}",
        );
    }

    /**
     * Validates a card number without running a transaction or authorizing a charge.
     *
     * @param {Payabli.RequestPaymentValidate} request
     * @param {MoneyInClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Payabli.BadRequestError}
     * @throws {@link Payabli.UnauthorizedError}
     * @throws {@link Payabli.InternalServerError}
     * @throws {@link Payabli.ServiceUnavailableError}
     *
     * @example
     *     await client.moneyIn.validate({
     *         idempotencyKey: "6B29FC40-CA47-1067-B31D-00DD010662DA",
     *         entryPoint: "entry132",
     *         paymentMethod: {
     *             method: "card",
     *             cardnumber: "4360000001000005",
     *             cardexp: "12/29",
     *             cardzip: "14602-8328",
     *             cardHolder: "Dianne Becker-Smith"
     *         }
     *     })
     */
    public validate(
        request: Payabli.RequestPaymentValidate,
        requestOptions?: MoneyInClient.RequestOptions,
    ): core.HttpResponsePromise<Payabli.ValidateResponse> {
        return core.HttpResponsePromise.fromPromise(this.__validate(request, requestOptions));
    }

    private async __validate(
        request: Payabli.RequestPaymentValidate,
        requestOptions?: MoneyInClient.RequestOptions,
    ): Promise<core.WithRawResponse<Payabli.ValidateResponse>> {
        const { idempotencyKey, ..._body } = request;
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({ idempotencyKey: idempotencyKey != null ? idempotencyKey : undefined }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PayabliEnvironment.Sandbox,
                "MoneyIn/validate",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: _body,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Payabli.ValidateResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Payabli.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Payabli.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Payabli.InternalServerError(_response.error.body as unknown, _response.rawResponse);
                case 503:
                    throw new Payabli.ServiceUnavailableError(
                        _response.error.body as Payabli.PayabliApiResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PayabliError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/MoneyIn/validate");
    }

    /**
     * Cancel a transaction that hasn't been settled yet. Voiding non-captured authorizations prevents future captures. If a transaction has been settled, refund it instead.
     *
     *   <Tip>
     *   Consider migrating to the [v2 Void endpoint](/developers/api-reference/moneyinV2/void-a-transaction) to take advantage of unified response codes and improved response consistency.
     *   </Tip>
     *
     * @param {string} transId - ReferenceId for the transaction (PaymentId).
     * @param {MoneyInClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Payabli.BadRequestError}
     * @throws {@link Payabli.UnauthorizedError}
     * @throws {@link Payabli.InternalServerError}
     * @throws {@link Payabli.ServiceUnavailableError}
     *
     * @example
     *     await client.moneyIn.void("10-3ffa27df-b171-44e0-b251-e95fbfc7a723")
     */
    public void(
        transId: string,
        requestOptions?: MoneyInClient.RequestOptions,
    ): core.HttpResponsePromise<Payabli.VoidResponse> {
        return core.HttpResponsePromise.fromPromise(this.__void(transId, requestOptions));
    }

    private async __void(
        transId: string,
        requestOptions?: MoneyInClient.RequestOptions,
    ): Promise<core.WithRawResponse<Payabli.VoidResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PayabliEnvironment.Sandbox,
                `MoneyIn/void/${core.url.encodePathParam(transId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Payabli.VoidResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Payabli.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Payabli.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Payabli.InternalServerError(_response.error.body as unknown, _response.rawResponse);
                case 503:
                    throw new Payabli.ServiceUnavailableError(
                        _response.error.body as Payabli.PayabliApiResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PayabliError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/MoneyIn/void/{transId}");
    }

    /**
     * Make a single transaction. This method authorizes and captures a payment in one step. This is the v2 version of the `api/MoneyIn/getpaid` endpoint, and returns the unified response format. See [Pay In unified response codes reference](/guides/pay-in-unified-response-codes-reference) for more information.
     *
     * @param {Payabli.RequestPaymentV2} request
     * @param {MoneyInClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Payabli.BadRequestAuthResponseErrorV2}
     * @throws {@link Payabli.UnauthorizedError}
     * @throws {@link Payabli.DeclinedAuthResponseErrorV2}
     * @throws {@link Payabli.InternalServerResponseErrorV2}
     *
     * @example
     *     await client.moneyIn.getpaidv2({
     *         body: {
     *             customerData: {
     *                 customerId: 4440
     *             },
     *             entryPoint: "f743aed24a",
     *             ipaddress: "255.255.255.255",
     *             paymentDetails: {
     *                 serviceFee: 0,
     *                 totalAmount: 100
     *             },
     *             paymentMethod: {
     *                 cardcvv: "999",
     *                 cardexp: "02/27",
     *                 cardHolder: "John Cassian",
     *                 cardnumber: "4111111111111111",
     *                 cardzip: "12345",
     *                 initiator: "payor",
     *                 method: "card"
     *             }
     *         }
     *     })
     *
     * @example
     *     await client.moneyIn.getpaidv2({
     *         body: {
     *             customerData: {
     *                 customerId: 4440
     *             },
     *             entryPoint: "f743aed24a",
     *             ipaddress: "255.255.255.255",
     *             paymentDetails: {
     *                 serviceFee: 0,
     *                 totalAmount: 100
     *             },
     *             paymentMethod: {
     *                 initiator: "payor",
     *                 method: "card",
     *                 storedMethodId: "1ec55af9-7b5a-4ff0-81ed-c12d2f95e135-4440",
     *                 storedMethodUsageType: "unscheduled"
     *             }
     *         }
     *     })
     *
     * @example
     *     await client.moneyIn.getpaidv2({
     *         body: {
     *             customerData: {
     *                 customerId: 4440
     *             },
     *             entryPoint: "f743aed24a",
     *             ipaddress: "255.255.255.255",
     *             paymentDetails: {
     *                 serviceFee: 0,
     *                 totalAmount: 100
     *             },
     *             paymentMethod: {
     *                 achAccount: "123123123",
     *                 achAccountType: "Checking",
     *                 achCode: "WEB",
     *                 achHolder: "John Cassian",
     *                 achHolderType: "personal",
     *                 achRouting: "123123123",
     *                 method: "ach"
     *             }
     *         }
     *     })
     *
     * @example
     *     await client.moneyIn.getpaidv2({
     *         body: {
     *             customerData: {
     *                 customerId: 4440
     *             },
     *             entryPoint: "f743aed24a",
     *             ipaddress: "255.255.255.255",
     *             paymentDetails: {
     *                 serviceFee: 0,
     *                 totalAmount: 100
     *             },
     *             paymentMethod: {
     *                 device: "6c361c7d-674c-44cc-b790-382b75d1xxx",
     *                 method: "cloud",
     *                 saveIfSuccess: true
     *             }
     *         }
     *     })
     */
    public getpaidv2(
        request: Payabli.RequestPaymentV2,
        requestOptions?: MoneyInClient.RequestOptions,
    ): core.HttpResponsePromise<Payabli.V2TransactionResponseWrapper> {
        return core.HttpResponsePromise.fromPromise(this.__getpaidv2(request, requestOptions));
    }

    private async __getpaidv2(
        request: Payabli.RequestPaymentV2,
        requestOptions?: MoneyInClient.RequestOptions,
    ): Promise<core.WithRawResponse<Payabli.V2TransactionResponseWrapper>> {
        const { achValidation, forceCustomerCreation, idempotencyKey, validationCode, body: _body } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (achValidation != null) {
            _queryParams.achValidation = achValidation.toString();
        }

        if (forceCustomerCreation != null) {
            _queryParams.forceCustomerCreation = forceCustomerCreation.toString();
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                idempotencyKey: idempotencyKey != null ? idempotencyKey : undefined,
                validationCode: validationCode != null ? validationCode : undefined,
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PayabliEnvironment.Sandbox,
                "v2/MoneyIn/getpaid",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            requestType: "json",
            body: _body,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Payabli.V2TransactionResponseWrapper, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Payabli.BadRequestAuthResponseErrorV2(
                        _response.error.body as Payabli.V2BadRequestError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Payabli.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 402:
                    throw new Payabli.DeclinedAuthResponseErrorV2(
                        _response.error.body as Payabli.V2DeclinedTransactionResponseWrapper,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Payabli.InternalServerResponseErrorV2(
                        _response.error.body as Payabli.V2InternalServerError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PayabliError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v2/MoneyIn/getpaid");
    }

    /**
     * Authorize a card transaction. This returns an authorization code and reserves funds for the merchant. Authorized transactions aren't flagged for settlement until captured. This is the v2 version of the `api/MoneyIn/authorize` endpoint, and returns the unified response format. See [Pay In unified response codes reference](/guides/pay-in-unified-response-codes-reference) for more information.
     *
     * **Note**: Only card transactions can be authorized. This endpoint can't be used for ACH transactions.
     *
     * @param {Payabli.RequestPaymentAuthorizeV2} request
     * @param {MoneyInClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Payabli.BadRequestAuthResponseErrorV2}
     * @throws {@link Payabli.UnauthorizedError}
     * @throws {@link Payabli.DeclinedAuthResponseErrorV2}
     * @throws {@link Payabli.InternalServerResponseErrorV2}
     *
     * @example
     *     await client.moneyIn.authorizev2({
     *         body: {
     *             customerData: {
     *                 customerId: 4440
     *             },
     *             entryPoint: "f743aed24a",
     *             ipaddress: "255.255.255.255",
     *             paymentDetails: {
     *                 serviceFee: 0,
     *                 totalAmount: 100
     *             },
     *             paymentMethod: {
     *                 cardcvv: "999",
     *                 cardexp: "02/27",
     *                 cardHolder: "John Cassian",
     *                 cardnumber: "4111111111111111",
     *                 cardzip: "12345",
     *                 initiator: "payor",
     *                 method: "card"
     *             }
     *         }
     *     })
     */
    public authorizev2(
        request: Payabli.RequestPaymentAuthorizeV2,
        requestOptions?: MoneyInClient.RequestOptions,
    ): core.HttpResponsePromise<Payabli.V2TransactionResponseWrapper> {
        return core.HttpResponsePromise.fromPromise(this.__authorizev2(request, requestOptions));
    }

    private async __authorizev2(
        request: Payabli.RequestPaymentAuthorizeV2,
        requestOptions?: MoneyInClient.RequestOptions,
    ): Promise<core.WithRawResponse<Payabli.V2TransactionResponseWrapper>> {
        const { forceCustomerCreation, idempotencyKey, body: _body } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (forceCustomerCreation != null) {
            _queryParams.forceCustomerCreation = forceCustomerCreation.toString();
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({ idempotencyKey: idempotencyKey != null ? idempotencyKey : undefined }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PayabliEnvironment.Sandbox,
                "v2/MoneyIn/authorize",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            requestType: "json",
            body: _body,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Payabli.V2TransactionResponseWrapper, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Payabli.BadRequestAuthResponseErrorV2(
                        _response.error.body as Payabli.V2BadRequestError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Payabli.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 402:
                    throw new Payabli.DeclinedAuthResponseErrorV2(
                        _response.error.body as Payabli.V2DeclinedTransactionResponseWrapper,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Payabli.InternalServerResponseErrorV2(
                        _response.error.body as Payabli.V2InternalServerError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PayabliError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v2/MoneyIn/authorize");
    }

    /**
     * Capture an authorized transaction to complete the transaction and move funds from the customer to merchant account. This is the v2 version of the `api/MoneyIn/capture/{transId}` endpoint, and returns the unified response format. See [Pay In unified response codes reference](/guides/pay-in-unified-response-codes-reference) for more information.
     *
     * @param {string} transId - ReferenceId for the transaction (PaymentId).
     * @param {Payabli.CaptureRequest} request
     * @param {MoneyInClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Payabli.BadRequestCaptureResponseErrorV2}
     * @throws {@link Payabli.UnauthorizedError}
     * @throws {@link Payabli.DeclinedCaptureResponseErrorV2}
     * @throws {@link Payabli.InternalServerResponseErrorV2}
     *
     * @example
     *     await client.moneyIn.capturev2("10-7d9cd67d-2d5d-4cd7-a1b7-72b8b201ec13", {
     *         paymentDetails: {
     *             totalAmount: 105,
     *             serviceFee: 5
     *         }
     *     })
     *
     * @example
     *     await client.moneyIn.capturev2("10-7d9cd67d-2d5d-4cd7-a1b7-72b8b201ec13", {
     *         paymentDetails: {
     *             totalAmount: 89,
     *             serviceFee: 4
     *         }
     *     })
     */
    public capturev2(
        transId: string,
        request: Payabli.CaptureRequest,
        requestOptions?: MoneyInClient.RequestOptions,
    ): core.HttpResponsePromise<Payabli.V2TransactionResponseWrapper> {
        return core.HttpResponsePromise.fromPromise(this.__capturev2(transId, request, requestOptions));
    }

    private async __capturev2(
        transId: string,
        request: Payabli.CaptureRequest,
        requestOptions?: MoneyInClient.RequestOptions,
    ): Promise<core.WithRawResponse<Payabli.V2TransactionResponseWrapper>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PayabliEnvironment.Sandbox,
                `v2/MoneyIn/capture/${core.url.encodePathParam(transId)}`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Payabli.V2TransactionResponseWrapper, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Payabli.BadRequestCaptureResponseErrorV2(
                        _response.error.body as Payabli.V2BadRequestError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Payabli.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 402:
                    throw new Payabli.DeclinedCaptureResponseErrorV2(
                        _response.error.body as Payabli.V2DeclinedTransactionResponseWrapper,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Payabli.InternalServerResponseErrorV2(
                        _response.error.body as Payabli.V2InternalServerError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PayabliError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "POST",
            "/v2/MoneyIn/capture/{transId}",
        );
    }

    /**
     * Give a full refund for a transaction that has settled and send money back to the account holder. To perform a partial refund, see [Partially refund a transaction](developers/api-reference/moneyinV2/partial-refund-a-settled-transaction).
     *
     * This is the v2 version of the refund endpoint, and returns the unified response format. See [Pay In unified response codes reference](/guides/pay-in-unified-response-codes-reference) for more information.
     *
     * @param {string} transId - ReferenceId for the transaction (PaymentId).
     * @param {MoneyInClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Payabli.BadRequestRefundResponseErrorV2}
     * @throws {@link Payabli.UnauthorizedError}
     * @throws {@link Payabli.DeclinedRefundResponseErrorV2}
     * @throws {@link Payabli.InternalServerResponseErrorV2}
     *
     * @example
     *     await client.moneyIn.refundv2("10-3ffa27df-b171-44e0-b251-e95fbfc7a723")
     */
    public refundv2(
        transId: string,
        requestOptions?: MoneyInClient.RequestOptions,
    ): core.HttpResponsePromise<Payabli.V2TransactionResponseWrapper> {
        return core.HttpResponsePromise.fromPromise(this.__refundv2(transId, requestOptions));
    }

    private async __refundv2(
        transId: string,
        requestOptions?: MoneyInClient.RequestOptions,
    ): Promise<core.WithRawResponse<Payabli.V2TransactionResponseWrapper>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PayabliEnvironment.Sandbox,
                `v2/MoneyIn/refund/${core.url.encodePathParam(transId)}`,
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Payabli.V2TransactionResponseWrapper, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Payabli.BadRequestRefundResponseErrorV2(
                        _response.error.body as Payabli.V2BadRequestError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Payabli.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 402:
                    throw new Payabli.DeclinedRefundResponseErrorV2(
                        _response.error.body as Payabli.V2DeclinedTransactionResponseWrapper,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Payabli.InternalServerResponseErrorV2(
                        _response.error.body as Payabli.V2InternalServerError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PayabliError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v2/MoneyIn/refund/{transId}");
    }

    /**
     * Refund a transaction that has settled and send money back to the account holder. If `amount` is omitted or set to 0, performs a full refund. When a non-zero `amount` is provided, this endpoint performs a partial refund.
     *
     * This is the v2 version of the refund endpoint, and returns the unified response format. See [Pay In unified response codes reference](/guides/pay-in-unified-response-codes-reference) for more information.
     *
     * @param {string} transId - ReferenceId for the transaction (PaymentId).
     * @param {number} amount - Amount to refund from original transaction, minus any service fees charged on the original transaction. If omitted or set to 0, performs a full refund.
     * @param {MoneyInClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Payabli.BadRequestRefundResponseErrorV2}
     * @throws {@link Payabli.UnauthorizedError}
     * @throws {@link Payabli.DeclinedRefundResponseErrorV2}
     * @throws {@link Payabli.InternalServerResponseErrorV2}
     *
     * @example
     *     await client.moneyIn.refundv2Amount("10-3ffa27df-b171-44e0-b251-e95fbfc7a723", 0)
     *
     * @example
     *     await client.moneyIn.refundv2Amount("10-3ffa27df-b171-44e0-b251-e95fbfc7a723", 100.99)
     */
    public refundv2Amount(
        transId: string,
        amount: number,
        requestOptions?: MoneyInClient.RequestOptions,
    ): core.HttpResponsePromise<Payabli.V2TransactionResponseWrapper> {
        return core.HttpResponsePromise.fromPromise(this.__refundv2Amount(transId, amount, requestOptions));
    }

    private async __refundv2Amount(
        transId: string,
        amount: number,
        requestOptions?: MoneyInClient.RequestOptions,
    ): Promise<core.WithRawResponse<Payabli.V2TransactionResponseWrapper>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PayabliEnvironment.Sandbox,
                `v2/MoneyIn/refund/${core.url.encodePathParam(transId)}/${core.url.encodePathParam(amount)}`,
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Payabli.V2TransactionResponseWrapper, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Payabli.BadRequestRefundResponseErrorV2(
                        _response.error.body as Payabli.V2BadRequestError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Payabli.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 402:
                    throw new Payabli.DeclinedRefundResponseErrorV2(
                        _response.error.body as Payabli.V2DeclinedTransactionResponseWrapper,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Payabli.InternalServerResponseErrorV2(
                        _response.error.body as Payabli.V2InternalServerError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PayabliError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "POST",
            "/v2/MoneyIn/refund/{transId}/{amount}",
        );
    }

    /**
     * Cancel a transaction that hasn't been settled yet. Voiding non-captured authorizations prevents future captures. This is the v2 version of the `api/MoneyIn/void/{transId}` endpoint, and returns the unified response format. See [Pay In unified response codes reference](/guides/pay-in-unified-response-codes-reference) for more information.
     *
     * @param {string} transId - ReferenceId for the transaction (PaymentId).
     * @param {MoneyInClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Payabli.BadRequestVoidResponseErrorV2}
     * @throws {@link Payabli.UnauthorizedError}
     * @throws {@link Payabli.DeclinedVoidResponseErrorV2}
     * @throws {@link Payabli.InternalServerResponseErrorV2}
     *
     * @example
     *     await client.moneyIn.voidv2("10-3ffa27df-b171-44e0-b251-e95fbfc7a723")
     */
    public voidv2(
        transId: string,
        requestOptions?: MoneyInClient.RequestOptions,
    ): core.HttpResponsePromise<Payabli.V2TransactionResponseWrapper> {
        return core.HttpResponsePromise.fromPromise(this.__voidv2(transId, requestOptions));
    }

    private async __voidv2(
        transId: string,
        requestOptions?: MoneyInClient.RequestOptions,
    ): Promise<core.WithRawResponse<Payabli.V2TransactionResponseWrapper>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PayabliEnvironment.Sandbox,
                `v2/MoneyIn/void/${core.url.encodePathParam(transId)}`,
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Payabli.V2TransactionResponseWrapper, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Payabli.BadRequestVoidResponseErrorV2(
                        _response.error.body as Payabli.V2BadRequestError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Payabli.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 402:
                    throw new Payabli.DeclinedVoidResponseErrorV2(
                        _response.error.body as Payabli.V2DeclinedTransactionResponseWrapper,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Payabli.InternalServerResponseErrorV2(
                        _response.error.body as Payabli.V2InternalServerError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PayabliError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/v2/MoneyIn/void/{transId}");
    }
}
