/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as Payabli from "../../../index.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import * as errors from "../../../../errors/index.js";

export declare namespace MoneyIn {
    export interface Options {
        environment?: core.Supplier<environments.PayabliEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        apiKey?: core.Supplier<string | undefined>;
        /** Additional headers to include in requests. */
        headers?: Record<string, string | core.Supplier<string | null | undefined> | null | undefined>;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Additional query string parameters to include in the request. */
        queryParams?: Record<string, unknown>;
        /** Additional headers to include in the request. */
        headers?: Record<string, string | core.Supplier<string | null | undefined> | null | undefined>;
    }
}

export class MoneyIn {
    protected readonly _options: MoneyIn.Options;

    constructor(_options: MoneyIn.Options = {}) {
        this._options = _options;
    }

    /**
     * Authorize a card transaction. This returns an authorization code and reserves funds for the merchant. Authorized transactions aren't flagged for settlement until [captured](/api-reference/moneyin/capture-an-authorized-transaction).
     *
     * **Note**: Only card transactions can be authorized. This endpoint can't be used for ACH transactions.
     *
     * @param {Payabli.RequestPaymentAuthorize} request
     * @param {MoneyIn.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Payabli.BadRequestError}
     * @throws {@link Payabli.UnauthorizedError}
     * @throws {@link Payabli.InternalServerError}
     * @throws {@link Payabli.ServiceUnavailableError}
     *
     * @example
     *     await client.moneyIn.authorize({
     *         body: {
     *             customerData: {
     *                 customerId: 4440
     *             },
     *             entryPoint: "f743aed24a",
     *             ipaddress: "255.255.255.255",
     *             paymentDetails: {
     *                 serviceFee: 0,
     *                 totalAmount: 100
     *             },
     *             paymentMethod: {
     *                 cardcvv: "999",
     *                 cardexp: "02/27",
     *                 cardHolder: "John Cassian",
     *                 cardnumber: "4111111111111111",
     *                 cardzip: "12345",
     *                 initiator: "payor",
     *                 method: "card"
     *             }
     *         }
     *     })
     */
    public authorize(
        request: Payabli.RequestPaymentAuthorize,
        requestOptions?: MoneyIn.RequestOptions,
    ): core.HttpResponsePromise<Payabli.AuthResponse> {
        return core.HttpResponsePromise.fromPromise(this.__authorize(request, requestOptions));
    }

    private async __authorize(
        request: Payabli.RequestPaymentAuthorize,
        requestOptions?: MoneyIn.RequestOptions,
    ): Promise<core.WithRawResponse<Payabli.AuthResponse>> {
        const { forceCustomerCreation, idempotencyKey, body: _body } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (forceCustomerCreation != null) {
            _queryParams["forceCustomerCreation"] = forceCustomerCreation.toString();
        }

        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                idempotencyKey: idempotencyKey != null ? idempotencyKey : undefined,
                ...(await this._getCustomAuthorizationHeaders()),
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PayabliEnvironment.Sandbox,
                "MoneyIn/authorize",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            requestType: "json",
            body: _body,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Payabli.AuthResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Payabli.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Payabli.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Payabli.InternalServerError(_response.error.body as unknown, _response.rawResponse);
                case 503:
                    throw new Payabli.ServiceUnavailableError(
                        _response.error.body as Payabli.PayabliApiResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PayabliError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.PayabliError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.PayabliTimeoutError("Timeout exceeded when calling POST /MoneyIn/authorize.");
            case "unknown":
                throw new errors.PayabliError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * <Warning>
     *   This endpoint is deprecated and will be sunset on November 24, 2025. Migrate to [POST `/capture/{transId}`](/api-reference/moneyin/capture-an-authorized-transaction)`.
     * </Warning>
     *
     *   Capture an [authorized
     * transaction](/api-reference/moneyin/authorize-a-transaction) to complete the transaction and move funds from the customer to merchant account.
     *
     * @param {number} amount - Amount to be captured. The amount can't be greater the original total amount of the transaction. `0` captures the total amount authorized in the transaction. Partial captures aren't supported.
     * @param {string} transId - ReferenceId for the transaction (PaymentId).
     * @param {MoneyIn.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Payabli.BadRequestError}
     * @throws {@link Payabli.UnauthorizedError}
     * @throws {@link Payabli.InternalServerError}
     * @throws {@link Payabli.ServiceUnavailableError}
     *
     * @example
     *     await client.moneyIn.capture(0, "10-7d9cd67d-2d5d-4cd7-a1b7-72b8b201ec13")
     */
    public capture(
        amount: number,
        transId: string,
        requestOptions?: MoneyIn.RequestOptions,
    ): core.HttpResponsePromise<Payabli.CaptureResponse> {
        return core.HttpResponsePromise.fromPromise(this.__capture(amount, transId, requestOptions));
    }

    private async __capture(
        amount: number,
        transId: string,
        requestOptions?: MoneyIn.RequestOptions,
    ): Promise<core.WithRawResponse<Payabli.CaptureResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PayabliEnvironment.Sandbox,
                `MoneyIn/capture/${encodeURIComponent(transId)}/${encodeURIComponent(amount)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Payabli.CaptureResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Payabli.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Payabli.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Payabli.InternalServerError(_response.error.body as unknown, _response.rawResponse);
                case 503:
                    throw new Payabli.ServiceUnavailableError(
                        _response.error.body as Payabli.PayabliApiResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PayabliError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.PayabliError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.PayabliTimeoutError(
                    "Timeout exceeded when calling GET /MoneyIn/capture/{transId}/{amount}.",
                );
            case "unknown":
                throw new errors.PayabliError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Capture an [authorized transaction](/api-reference/moneyin/authorize-a-transaction) to complete the transaction and move funds from the customer to merchant account.
     *
     * You can use this endpoint to capture both full and partial amounts of the original authorized transaction. See [Capture an authorized transaction](/developers/developer-guides/pay-in-auth-and-capture) for more information about this endpoint.
     *
     * @param {string} transId - ReferenceId for the transaction (PaymentId).
     * @param {Payabli.CaptureRequest} request
     * @param {MoneyIn.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Payabli.BadRequestError}
     * @throws {@link Payabli.UnauthorizedError}
     * @throws {@link Payabli.InternalServerError}
     * @throws {@link Payabli.ServiceUnavailableError}
     *
     * @example
     *     await client.moneyIn.captureAuth("10-7d9cd67d-2d5d-4cd7-a1b7-72b8b201ec13", {
     *         paymentDetails: {
     *             totalAmount: 105,
     *             serviceFee: 5
     *         }
     *     })
     *
     * @example
     *     await client.moneyIn.captureAuth("10-7d9cd67d-2d5d-4cd7-a1b7-72b8b201ec13", {
     *         paymentDetails: {
     *             totalAmount: 89,
     *             serviceFee: 4
     *         }
     *     })
     *
     * @example
     *     await client.moneyIn.captureAuth("10-7d9cd67d-2d5d-4cd7-a1b7-72b8b201ec13", {
     *         paymentDetails: {
     *             totalAmount: 100
     *         }
     *     })
     */
    public captureAuth(
        transId: string,
        request: Payabli.CaptureRequest,
        requestOptions?: MoneyIn.RequestOptions,
    ): core.HttpResponsePromise<Payabli.CaptureResponse> {
        return core.HttpResponsePromise.fromPromise(this.__captureAuth(transId, request, requestOptions));
    }

    private async __captureAuth(
        transId: string,
        request: Payabli.CaptureRequest,
        requestOptions?: MoneyIn.RequestOptions,
    ): Promise<core.WithRawResponse<Payabli.CaptureResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PayabliEnvironment.Sandbox,
                `MoneyIn/capture/${encodeURIComponent(transId)}`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Payabli.CaptureResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Payabli.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Payabli.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Payabli.InternalServerError(_response.error.body as unknown, _response.rawResponse);
                case 503:
                    throw new Payabli.ServiceUnavailableError(
                        _response.error.body as Payabli.PayabliApiResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PayabliError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.PayabliError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.PayabliTimeoutError("Timeout exceeded when calling POST /MoneyIn/capture/{transId}.");
            case "unknown":
                throw new errors.PayabliError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Make a temporary microdeposit in a customer account to verify the customer's ownership and access to the target account. Reverse the microdeposit with `reverseCredit`.
     *
     * This feature must be enabled by Payabli on a per-merchant basis. Contact support for help.
     *
     * @param {Payabli.RequestCredit} request
     * @param {MoneyIn.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Payabli.BadRequestError}
     * @throws {@link Payabli.UnauthorizedError}
     * @throws {@link Payabli.InternalServerError}
     * @throws {@link Payabli.ServiceUnavailableError}
     *
     * @example
     *     await client.moneyIn.credit({
     *         idempotencyKey: "6B29FC40-CA47-1067-B31D-00DD010662DA",
     *         customerData: {
     *             billingAddress1: "5127 Linkwood ave",
     *             customerNumber: "100"
     *         },
     *         entrypoint: "my-entrypoint",
     *         paymentDetails: {
     *             serviceFee: 0,
     *             totalAmount: 1
     *         },
     *         paymentMethod: {
     *             achAccount: "88354454",
     *             achAccountType: "Checking",
     *             achHolder: "John Smith",
     *             achRouting: "021000021",
     *             method: "ach"
     *         }
     *     })
     *
     * @example
     *     await client.moneyIn.credit({
     *         idempotencyKey: "6B29FC40-CA47-1067-B31D-00DD010662DA",
     *         customerData: {
     *             billingAddress1: "125 Main Street",
     *             billingCity: "Kingsport",
     *             billingEmail: "johnnyp@email.com",
     *             company: "Acme, Inc",
     *             customerNumber: "100",
     *             firstName: "Johnny",
     *             lastName: "Poulsbo"
     *         },
     *         entrypoint: "my-entrypoint",
     *         paymentDetails: {
     *             serviceFee: 0,
     *             totalAmount: 1
     *         },
     *         paymentMethod: {
     *             achAccount: "88354554",
     *             achAccountType: "Checking",
     *             achHolder: "John Poulsbo",
     *             achRouting: "029000021",
     *             method: "ach"
     *         }
     *     })
     */
    public credit(
        request: Payabli.RequestCredit,
        requestOptions?: MoneyIn.RequestOptions,
    ): core.HttpResponsePromise<Payabli.PayabliApiResponse0> {
        return core.HttpResponsePromise.fromPromise(this.__credit(request, requestOptions));
    }

    private async __credit(
        request: Payabli.RequestCredit,
        requestOptions?: MoneyIn.RequestOptions,
    ): Promise<core.WithRawResponse<Payabli.PayabliApiResponse0>> {
        const { forceCustomerCreation, idempotencyKey, ..._body } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (forceCustomerCreation != null) {
            _queryParams["forceCustomerCreation"] = forceCustomerCreation.toString();
        }

        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                idempotencyKey: idempotencyKey != null ? idempotencyKey : undefined,
                ...(await this._getCustomAuthorizationHeaders()),
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PayabliEnvironment.Sandbox,
                "MoneyIn/makecredit",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            requestType: "json",
            body: _body,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Payabli.PayabliApiResponse0, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Payabli.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Payabli.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Payabli.InternalServerError(_response.error.body as unknown, _response.rawResponse);
                case 503:
                    throw new Payabli.ServiceUnavailableError(
                        _response.error.body as Payabli.PayabliApiResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PayabliError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.PayabliError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.PayabliTimeoutError("Timeout exceeded when calling POST /MoneyIn/makecredit.");
            case "unknown":
                throw new errors.PayabliError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Retrieve a processed transaction's details.
     *
     * @param {string} transId - ReferenceId for the transaction (PaymentId).
     * @param {MoneyIn.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Payabli.BadRequestError}
     * @throws {@link Payabli.UnauthorizedError}
     * @throws {@link Payabli.InternalServerError}
     * @throws {@link Payabli.ServiceUnavailableError}
     *
     * @example
     *     await client.moneyIn.details("45-as456777hhhhhhhhhh77777777-324")
     */
    public details(
        transId: string,
        requestOptions?: MoneyIn.RequestOptions,
    ): core.HttpResponsePromise<Payabli.TransactionQueryRecords> {
        return core.HttpResponsePromise.fromPromise(this.__details(transId, requestOptions));
    }

    private async __details(
        transId: string,
        requestOptions?: MoneyIn.RequestOptions,
    ): Promise<core.WithRawResponse<Payabli.TransactionQueryRecords>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PayabliEnvironment.Sandbox,
                `MoneyIn/details/${encodeURIComponent(transId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Payabli.TransactionQueryRecords, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Payabli.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Payabli.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Payabli.InternalServerError(_response.error.body as unknown, _response.rawResponse);
                case 503:
                    throw new Payabli.ServiceUnavailableError(
                        _response.error.body as Payabli.PayabliApiResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PayabliError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.PayabliError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.PayabliTimeoutError("Timeout exceeded when calling GET /MoneyIn/details/{transId}.");
            case "unknown":
                throw new errors.PayabliError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Make a single transaction. This method authorizes and captures a payment in one step.
     *
     * @param {Payabli.RequestPayment} request
     * @param {MoneyIn.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Payabli.BadRequestError}
     * @throws {@link Payabli.UnauthorizedError}
     * @throws {@link Payabli.InternalServerError}
     * @throws {@link Payabli.ServiceUnavailableError}
     *
     * @example
     *     await client.moneyIn.getpaid({
     *         body: {
     *             customerData: {
     *                 customerId: 4440
     *             },
     *             entryPoint: "f743aed24a",
     *             ipaddress: "255.255.255.255",
     *             paymentDetails: {
     *                 serviceFee: 0,
     *                 totalAmount: 100
     *             },
     *             paymentMethod: {
     *                 cardcvv: "999",
     *                 cardexp: "02/27",
     *                 cardHolder: "John Cassian",
     *                 cardnumber: "4111111111111111",
     *                 cardzip: "12345",
     *                 initiator: "payor",
     *                 method: "card"
     *             }
     *         }
     *     })
     *
     * @example
     *     await client.moneyIn.getpaid({
     *         body: {
     *             customerData: {
     *                 customerId: 4440
     *             },
     *             entryPoint: "f743aed24a",
     *             ipaddress: "255.255.255.255",
     *             paymentDetails: {
     *                 serviceFee: 0,
     *                 totalAmount: 100
     *             },
     *             paymentMethod: {
     *                 initiator: "payor",
     *                 method: "card",
     *                 storedMethodId: "1ec55af9-7b5a-4ff0-81ed-c12d2f95e135-4440",
     *                 storedMethodUsageType: "unscheduled"
     *             }
     *         }
     *     })
     *
     * @example
     *     await client.moneyIn.getpaid({
     *         body: {
     *             customerData: {
     *                 customerId: 4440
     *             },
     *             entryPoint: "f743aed24a",
     *             ipaddress: "255.255.255.255",
     *             paymentDetails: {
     *                 serviceFee: 0,
     *                 totalAmount: 100
     *             },
     *             paymentMethod: {
     *                 device: "6c361c7d-674c-44cc-b790-382b75d1xxx",
     *                 method: "cloud",
     *                 saveIfSuccess: true
     *             }
     *         }
     *     })
     *
     * @example
     *     await client.moneyIn.getpaid({
     *         body: {
     *             customerData: {
     *                 customerId: 4440
     *             },
     *             entryPoint: "f743aed24a",
     *             ipaddress: "255.255.255.255",
     *             paymentDetails: {
     *                 serviceFee: 0,
     *                 totalAmount: 100
     *             },
     *             paymentMethod: {
     *                 achAccount: "123123123",
     *                 achAccountType: "Checking",
     *                 achCode: "WEB",
     *                 achHolder: "John Cassian",
     *                 achHolderType: "personal",
     *                 achRouting: "123123123",
     *                 method: "ach"
     *             }
     *         }
     *     })
     *
     * @example
     *     await client.moneyIn.getpaid({
     *         body: {
     *             customerData: {
     *                 billingAddress1: "123 Walnut Street",
     *                 billingCity: "Johnson City",
     *                 billingCountry: "US",
     *                 billingEmail: "john@email.com",
     *                 billingPhone: "1234567890",
     *                 billingState: "Johnson City",
     *                 billingZip: "37615",
     *                 customerNumber: "3456-7645A",
     *                 firstName: "John",
     *                 lastName: "Cassian"
     *             },
     *             entryPoint: "f743aed24a",
     *             ipaddress: "255.255.255.255",
     *             orderDescription: "New customer package",
     *             orderId: "982-102",
     *             paymentDetails: {
     *                 serviceFee: 0,
     *                 totalAmount: 1000
     *             },
     *             paymentMethod: {
     *                 cardcvv: "123",
     *                 cardexp: "02/25",
     *                 cardHolder: "John Cassian",
     *                 cardnumber: "4111111111111111",
     *                 cardzip: "12345",
     *                 initiator: "payor",
     *                 method: "card",
     *                 saveIfSuccess: true
     *             },
     *             source: "web"
     *         }
     *     })
     *
     * @example
     *     await client.moneyIn.getpaid({
     *         body: {
     *             customerData: {
     *                 customerId: 4440
     *             },
     *             entryPoint: "f743aed24a",
     *             ipaddress: "255.255.255.255",
     *             paymentDetails: {
     *                 serviceFee: 0,
     *                 totalAmount: 100,
     *                 currency: "CAD"
     *             },
     *             paymentMethod: {
     *                 cardcvv: "999",
     *                 cardexp: "02/27",
     *                 cardHolder: "John Cassian",
     *                 cardnumber: "4111111111111111",
     *                 cardzip: "12345",
     *                 initiator: "payor",
     *                 method: "card"
     *             }
     *         }
     *     })
     *
     * @example
     *     await client.moneyIn.getpaid({
     *         body: {
     *             customerData: {
     *                 customerId: 4440
     *             },
     *             entryPoint: "f743aed24a",
     *             ipaddress: "255.255.255.255",
     *             paymentDetails: {
     *                 serviceFee: 0,
     *                 totalAmount: 100
     *             },
     *             paymentMethod: {
     *                 cardcvv: "999",
     *                 cardexp: "02/27",
     *                 cardHolder: "Kassiane Cassian",
     *                 cardnumber: "4111111111111111",
     *                 cardzip: "12345",
     *                 initiator: "payor",
     *                 method: "card"
     *             }
     *         }
     *     })
     */
    public getpaid(
        request: Payabli.RequestPayment,
        requestOptions?: MoneyIn.RequestOptions,
    ): core.HttpResponsePromise<Payabli.PayabliApiResponseGetPaid> {
        return core.HttpResponsePromise.fromPromise(this.__getpaid(request, requestOptions));
    }

    private async __getpaid(
        request: Payabli.RequestPayment,
        requestOptions?: MoneyIn.RequestOptions,
    ): Promise<core.WithRawResponse<Payabli.PayabliApiResponseGetPaid>> {
        const { achValidation, forceCustomerCreation, idempotencyKey, validationCode, body: _body } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (achValidation != null) {
            _queryParams["achValidation"] = achValidation.toString();
        }

        if (forceCustomerCreation != null) {
            _queryParams["forceCustomerCreation"] = forceCustomerCreation.toString();
        }

        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                idempotencyKey: idempotencyKey != null ? idempotencyKey : undefined,
                validationCode: validationCode != null ? validationCode : undefined,
                ...(await this._getCustomAuthorizationHeaders()),
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PayabliEnvironment.Sandbox,
                "MoneyIn/getpaid",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            requestType: "json",
            body: _body,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Payabli.PayabliApiResponseGetPaid, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Payabli.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Payabli.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Payabli.InternalServerError(_response.error.body as unknown, _response.rawResponse);
                case 503:
                    throw new Payabli.ServiceUnavailableError(
                        _response.error.body as Payabli.PayabliApiResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PayabliError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.PayabliError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.PayabliTimeoutError("Timeout exceeded when calling POST /MoneyIn/getpaid.");
            case "unknown":
                throw new errors.PayabliError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * A reversal either refunds or voids a transaction independent of the transaction's settlement status. Send a reversal request for a transaction, and Payabli automatically determines whether it's a refund or void. You don't need to know whether the transaction is settled or not.
     *
     * @param {number} amount -
     *                          Amount to reverse from original transaction, minus any service fees charged on the original transaction.
     *
     *                          The amount provided can't be greater than the original total amount of the transaction, minus service fees. For example, if a transaction was $90 plus a $10 service fee, you can reverse up to $90.
     *
     *                          An amount equal to zero will refunds the total amount authorized minus any service fee.
     * @param {string} transId - ReferenceId for the transaction (PaymentId).
     * @param {MoneyIn.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Payabli.BadRequestError}
     * @throws {@link Payabli.UnauthorizedError}
     * @throws {@link Payabli.InternalServerError}
     * @throws {@link Payabli.ServiceUnavailableError}
     *
     * @example
     *     await client.moneyIn.reverse(0, "10-3ffa27df-b171-44e0-b251-e95fbfc7a723")
     *
     * @example
     *     await client.moneyIn.reverse(53.76, "10-3ffa27df-b171-44e0-b251-e95fbfc7a723")
     */
    public reverse(
        amount: number,
        transId: string,
        requestOptions?: MoneyIn.RequestOptions,
    ): core.HttpResponsePromise<Payabli.ReverseResponse> {
        return core.HttpResponsePromise.fromPromise(this.__reverse(amount, transId, requestOptions));
    }

    private async __reverse(
        amount: number,
        transId: string,
        requestOptions?: MoneyIn.RequestOptions,
    ): Promise<core.WithRawResponse<Payabli.ReverseResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PayabliEnvironment.Sandbox,
                `MoneyIn/reverse/${encodeURIComponent(transId)}/${encodeURIComponent(amount)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Payabli.ReverseResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Payabli.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Payabli.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Payabli.InternalServerError(_response.error.body as unknown, _response.rawResponse);
                case 503:
                    throw new Payabli.ServiceUnavailableError(
                        _response.error.body as Payabli.PayabliApiResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PayabliError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.PayabliError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.PayabliTimeoutError(
                    "Timeout exceeded when calling GET /MoneyIn/reverse/{transId}/{amount}.",
                );
            case "unknown":
                throw new errors.PayabliError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Refund a transaction that has settled and send money back to the account holder. If a transaction hasn't been settled, void it instead.
     *
     * @param {number} amount -
     *                          Amount to refund from original transaction, minus any service fees charged on the original transaction.
     *
     *                          The amount provided can't be greater than the original total amount of the transaction, minus service fees. For example, if a transaction was $90 plus a $10 service fee, you can refund up to $90.
     *
     *                          An amount equal to zero will refund the total amount authorized minus any service fee.
     * @param {string} transId - ReferenceId for the transaction (PaymentId).
     * @param {MoneyIn.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Payabli.BadRequestError}
     * @throws {@link Payabli.UnauthorizedError}
     * @throws {@link Payabli.InternalServerError}
     * @throws {@link Payabli.ServiceUnavailableError}
     *
     * @example
     *     await client.moneyIn.refund(0, "10-3ffa27df-b171-44e0-b251-e95fbfc7a723")
     *
     * @example
     *     await client.moneyIn.refund(100.99, "10-3ffa27df-b171-44e0-b251-e95fbfc7a723")
     */
    public refund(
        amount: number,
        transId: string,
        requestOptions?: MoneyIn.RequestOptions,
    ): core.HttpResponsePromise<Payabli.RefundResponse> {
        return core.HttpResponsePromise.fromPromise(this.__refund(amount, transId, requestOptions));
    }

    private async __refund(
        amount: number,
        transId: string,
        requestOptions?: MoneyIn.RequestOptions,
    ): Promise<core.WithRawResponse<Payabli.RefundResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PayabliEnvironment.Sandbox,
                `MoneyIn/refund/${encodeURIComponent(transId)}/${encodeURIComponent(amount)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Payabli.RefundResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Payabli.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Payabli.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Payabli.InternalServerError(_response.error.body as unknown, _response.rawResponse);
                case 503:
                    throw new Payabli.ServiceUnavailableError(
                        _response.error.body as Payabli.PayabliApiResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PayabliError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.PayabliError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.PayabliTimeoutError(
                    "Timeout exceeded when calling GET /MoneyIn/refund/{transId}/{amount}.",
                );
            case "unknown":
                throw new errors.PayabliError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Refunds a settled transaction with split instructions.
     *
     * @param {string} transId - ReferenceId for the transaction (PaymentId).
     * @param {Payabli.RequestRefund} request
     * @param {MoneyIn.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Payabli.BadRequestError}
     * @throws {@link Payabli.UnauthorizedError}
     * @throws {@link Payabli.InternalServerError}
     * @throws {@link Payabli.ServiceUnavailableError}
     *
     * @example
     *     await client.moneyIn.refundWithInstructions("10-3ffa27df-b171-44e0-b251-e95fbfc7a723", {
     *         idempotencyKey: "8A29FC40-CA47-1067-B31D-00DD010662DB",
     *         source: "api",
     *         orderDescription: "Materials deposit",
     *         amount: 100,
     *         refundDetails: {
     *             splitRefunding: [{
     *                     originationEntryPoint: "7f1a381696",
     *                     accountId: "187-342",
     *                     description: "Refunding undelivered materials",
     *                     amount: 60
     *                 }, {
     *                     originationEntryPoint: "7f1a381696",
     *                     accountId: "187-343",
     *                     description: "Refunding deposit for undelivered materials",
     *                     amount: 40
     *                 }]
     *         }
     *     })
     *
     * @example
     *     await client.moneyIn.refundWithInstructions("10-3ffa27df-b171-44e0-b251-e95fbfc7a723", {
     *         idempotencyKey: "8A29FC40-CA47-1067-B31D-00DD010662DB",
     *         source: "api",
     *         orderDescription: "Materials deposit",
     *         amount: 70,
     *         refundDetails: {
     *             splitRefunding: [{
     *                     originationEntryPoint: "7f1a381696",
     *                     accountId: "187-342",
     *                     description: "Refunding undelivered materials",
     *                     amount: 40
     *                 }, {
     *                     originationEntryPoint: "7f1a381696",
     *                     accountId: "187-343",
     *                     description: "Refunding deposit for undelivered materials",
     *                     amount: 30
     *                 }]
     *         }
     *     })
     */
    public refundWithInstructions(
        transId: string,
        request: Payabli.RequestRefund = {},
        requestOptions?: MoneyIn.RequestOptions,
    ): core.HttpResponsePromise<Payabli.RefundWithInstructionsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__refundWithInstructions(transId, request, requestOptions));
    }

    private async __refundWithInstructions(
        transId: string,
        request: Payabli.RequestRefund = {},
        requestOptions?: MoneyIn.RequestOptions,
    ): Promise<core.WithRawResponse<Payabli.RefundWithInstructionsResponse>> {
        const { idempotencyKey, ..._body } = request;
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                idempotencyKey: idempotencyKey != null ? idempotencyKey : undefined,
                ...(await this._getCustomAuthorizationHeaders()),
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PayabliEnvironment.Sandbox,
                `MoneyIn/refund/${encodeURIComponent(transId)}`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: _body,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Payabli.RefundWithInstructionsResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Payabli.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Payabli.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Payabli.InternalServerError(_response.error.body as unknown, _response.rawResponse);
                case 503:
                    throw new Payabli.ServiceUnavailableError(
                        _response.error.body as Payabli.PayabliApiResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PayabliError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.PayabliError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.PayabliTimeoutError("Timeout exceeded when calling POST /MoneyIn/refund/{transId}.");
            case "unknown":
                throw new errors.PayabliError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Reverse microdeposits that are used to verify customer account ownership and access. The `transId` value is returned in the success response for the original credit transaction made with `api/MoneyIn/makecredit`.
     *
     * @param {string} transId - ReferenceId for the transaction (PaymentId).
     * @param {MoneyIn.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Payabli.BadRequestError}
     * @throws {@link Payabli.UnauthorizedError}
     * @throws {@link Payabli.InternalServerError}
     * @throws {@link Payabli.ServiceUnavailableError}
     *
     * @example
     *     await client.moneyIn.reverseCredit("45-as456777hhhhhhhhhh77777777-324")
     */
    public reverseCredit(
        transId: string,
        requestOptions?: MoneyIn.RequestOptions,
    ): core.HttpResponsePromise<Payabli.PayabliApiResponse> {
        return core.HttpResponsePromise.fromPromise(this.__reverseCredit(transId, requestOptions));
    }

    private async __reverseCredit(
        transId: string,
        requestOptions?: MoneyIn.RequestOptions,
    ): Promise<core.WithRawResponse<Payabli.PayabliApiResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PayabliEnvironment.Sandbox,
                `MoneyIn/reverseCredit/${encodeURIComponent(transId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Payabli.PayabliApiResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Payabli.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Payabli.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Payabli.InternalServerError(_response.error.body as unknown, _response.rawResponse);
                case 503:
                    throw new Payabli.ServiceUnavailableError(
                        _response.error.body as Payabli.PayabliApiResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PayabliError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.PayabliError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.PayabliTimeoutError(
                    "Timeout exceeded when calling GET /MoneyIn/reverseCredit/{transId}.",
                );
            case "unknown":
                throw new errors.PayabliError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Send a payment receipt for a transaction.
     *
     * @param {string} transId - ReferenceId for the transaction (PaymentId).
     * @param {Payabli.SendReceipt2TransRequest} request
     * @param {MoneyIn.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Payabli.BadRequestError}
     * @throws {@link Payabli.UnauthorizedError}
     * @throws {@link Payabli.InternalServerError}
     * @throws {@link Payabli.ServiceUnavailableError}
     *
     * @example
     *     await client.moneyIn.sendReceipt2Trans("45-as456777hhhhhhhhhh77777777-324", {
     *         email: "example@email.com"
     *     })
     */
    public sendReceipt2Trans(
        transId: string,
        request: Payabli.SendReceipt2TransRequest = {},
        requestOptions?: MoneyIn.RequestOptions,
    ): core.HttpResponsePromise<Payabli.ReceiptResponse> {
        return core.HttpResponsePromise.fromPromise(this.__sendReceipt2Trans(transId, request, requestOptions));
    }

    private async __sendReceipt2Trans(
        transId: string,
        request: Payabli.SendReceipt2TransRequest = {},
        requestOptions?: MoneyIn.RequestOptions,
    ): Promise<core.WithRawResponse<Payabli.ReceiptResponse>> {
        const { email } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (email != null) {
            _queryParams["email"] = email;
        }

        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PayabliEnvironment.Sandbox,
                `MoneyIn/sendreceipt/${encodeURIComponent(transId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Payabli.ReceiptResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Payabli.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Payabli.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Payabli.InternalServerError(_response.error.body as unknown, _response.rawResponse);
                case 503:
                    throw new Payabli.ServiceUnavailableError(
                        _response.error.body as Payabli.PayabliApiResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PayabliError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.PayabliError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.PayabliTimeoutError(
                    "Timeout exceeded when calling GET /MoneyIn/sendreceipt/{transId}.",
                );
            case "unknown":
                throw new errors.PayabliError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Validates a card number without running a transaction or authorizing a charge.
     *
     * @param {Payabli.RequestPaymentValidate} request
     * @param {MoneyIn.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Payabli.BadRequestError}
     * @throws {@link Payabli.UnauthorizedError}
     * @throws {@link Payabli.InternalServerError}
     * @throws {@link Payabli.ServiceUnavailableError}
     *
     * @example
     *     await client.moneyIn.validate({
     *         idempotencyKey: "6B29FC40-CA47-1067-B31D-00DD010662DA",
     *         entryPoint: "entry132",
     *         paymentMethod: {
     *             method: "card",
     *             cardnumber: "4360000001000005",
     *             cardexp: "12/29",
     *             cardzip: "14602-8328",
     *             cardHolder: "Dianne Becker-Smith"
     *         }
     *     })
     */
    public validate(
        request: Payabli.RequestPaymentValidate,
        requestOptions?: MoneyIn.RequestOptions,
    ): core.HttpResponsePromise<Payabli.ValidateResponse> {
        return core.HttpResponsePromise.fromPromise(this.__validate(request, requestOptions));
    }

    private async __validate(
        request: Payabli.RequestPaymentValidate,
        requestOptions?: MoneyIn.RequestOptions,
    ): Promise<core.WithRawResponse<Payabli.ValidateResponse>> {
        const { idempotencyKey, ..._body } = request;
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                idempotencyKey: idempotencyKey != null ? idempotencyKey : undefined,
                ...(await this._getCustomAuthorizationHeaders()),
            }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PayabliEnvironment.Sandbox,
                "MoneyIn/validate",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: _body,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Payabli.ValidateResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Payabli.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Payabli.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Payabli.InternalServerError(_response.error.body as unknown, _response.rawResponse);
                case 503:
                    throw new Payabli.ServiceUnavailableError(
                        _response.error.body as Payabli.PayabliApiResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PayabliError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.PayabliError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.PayabliTimeoutError("Timeout exceeded when calling POST /MoneyIn/validate.");
            case "unknown":
                throw new errors.PayabliError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Cancel a transaction that hasn't been settled yet. Voiding non-captured authorizations prevents future captures. If a transaction has been settled, refund it instead.
     *
     * @param {string} transId - ReferenceId for the transaction (PaymentId).
     * @param {MoneyIn.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Payabli.BadRequestError}
     * @throws {@link Payabli.UnauthorizedError}
     * @throws {@link Payabli.InternalServerError}
     * @throws {@link Payabli.ServiceUnavailableError}
     *
     * @example
     *     await client.moneyIn.void("10-3ffa27df-b171-44e0-b251-e95fbfc7a723")
     */
    public void(
        transId: string,
        requestOptions?: MoneyIn.RequestOptions,
    ): core.HttpResponsePromise<Payabli.VoidResponse> {
        return core.HttpResponsePromise.fromPromise(this.__void(transId, requestOptions));
    }

    private async __void(
        transId: string,
        requestOptions?: MoneyIn.RequestOptions,
    ): Promise<core.WithRawResponse<Payabli.VoidResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PayabliEnvironment.Sandbox,
                `MoneyIn/void/${encodeURIComponent(transId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Payabli.VoidResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Payabli.BadRequestError(_response.error.body as unknown, _response.rawResponse);
                case 401:
                    throw new Payabli.UnauthorizedError(_response.error.body as unknown, _response.rawResponse);
                case 500:
                    throw new Payabli.InternalServerError(_response.error.body as unknown, _response.rawResponse);
                case 503:
                    throw new Payabli.ServiceUnavailableError(
                        _response.error.body as Payabli.PayabliApiResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.PayabliError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.PayabliError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.PayabliTimeoutError("Timeout exceeded when calling GET /MoneyIn/void/{transId}.");
            case "unknown":
                throw new errors.PayabliError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getCustomAuthorizationHeaders() {
        const apiKeyValue = await core.Supplier.get(this._options.apiKey);
        return { requestToken: apiKeyValue };
    }
}
